---
layout: post
title:  "객체 지향 프로그래밍"
date:   2019-08-29 17:48:45 +0900
tags: [CleanArchitecture]
categories: clean-architecture
subtitle : Clean Architecture - Item 5
feature-img: "assets/img/banner.jpg"
---

### 객체 지향 프로그래밍
#### 객체지향을 정의하는 요소
겍체지향을 표현하는 많은 말들이 있다. 보통 "데이터와 함수의 조합", "실제 세계를 모델링 하는 새로운 방법" 이라는 말을 들어봤을 것이다. 하지만 너무 모호하며 추상적이다.
어떤 사람들은 "객체지향이란 캡슐화, 상속, 다형성 이 세가지 개념을 조합한 것이거나, 또는 최소한 세가지 요소를 반드시 지원해야 한다." 고 말한다.

과연 사실일까?

<br>

### 캡슐화

<br>

![factory method pattern](/assets/images/post/191012/(3).png) 

객체지향은 데이터와 함수를 쉽고 효과적으로 캡슐화 하는 방법을 제공한다. 
이를 통해 데이터와 함수가 응집력 있게 구성된 집단을 서로 구분짓는 선을 그을 수 있다. 

구분선 바깥에서 데이터는 은닉되고, 일부 함수만이 외부에 노출된다. 
이러한 개념이 실제 객체지향 언어에서는 각각 클래스의 private 멤버 데이터와 public 멤버함수로 표현된다. 

캡슐화는 객체지향 프로그래밍 만의 것이 아니다. 어떤 면에서 객체지향이 캡슐화를 약화시켰다고 볼 수 있다.
또한 많은 객체지향 언어가 캡슐화를 거의 강제하지 않는다. 그저 프로그래머가 올바르게 지키기를 기대한다. 

<br>

### 상속

<br>

![factory method pattern](/assets/images/post/191012/(4).png) 

객체지향 언어가 고안되기 훨씬 전에도 상속과 비슷한 기법이 있었지만 절대 상속만큼 편리한 방식은 아니엿다. 또한 다중상속을 구현하기란 훨씬 더 어려운 일이었다. 

따라서 상속은 객체지향이 완전히 새롭게 만든 개념은 아니지만 편리한 방식으로 제공했다고 볼 수 있다.

<br>

### 다형성

객체지향개념에서 다형성이란 '여러 가지 형태를 가질 수 있는 능력'을 의미하며 자바에서는 한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있도록함으로써 다형성을 프로그램적으로 구현하였다.
대표적인 예로 오버로딩을 들수 있다.

![factory method pattern](/assets/images/post/191012/(5).png) 

그렇다면 다형성은 객체지향 프로그래밍이 처음 제공한 것일까?

함수를 가르키는 포인터를 응용한 것이 다형성이라는 점을 볼때 객체지향언어는 다형성을 제공하지는 못했지만, 다형성을 좀더 안전하고 편리하게 사용할 수 있게 해준다.
객체지향 프로그래밍을 사용한다면 다형성은 대수롭지 않은 일이 된다. 
이러한 이유로 객체지향은 제어흐름을 간접적으로 전환하는 규칙을 부과한다고 결론지을 수 있다.

<br>


#### 의존성 역전

다형성을 안전하게 적용할 수 있는 매커니즘의 등장 전을 살펴보자.
제어의 흐름은 시스템의 행위에 따라 결정되며, 소스코드의 의존성은 제어흐름에 따라 결정되었다.

하지만 다형성을 통하게 되면서 의존성 역전이 가능해졌다.

![factory method pattern](/assets/images/post/191012/(26).png){: width="60%" height="60%"}

HL1 모듈은 ML1 모듈의 F()함수를 호출한다. 소스코드에서는 HL1모듈은 인터페이스를 통해 F() 함수를 호출한다.

하지만 ML1과 I 인터페이스 사이의 소스 코드 의존성(상속관계)이 제어흐름과는 반대라는 것을 주목하자. 이는 의존성 역전 (dependency inversion)라고 부른다.

객체지향 언어가 다형성을 안전하고 편리하게 제공하며 소스 코드 의존성을 어디에서든 역전 시킬 수 있게 하였다. 
시스템의 소스 코드의존성 전부에 대해 방향을 결정 할 수 있는 절대적인 권한을 갖게 되었다는것을 의미한다.

이에 따라 배포 독립성과 개발 독립성을 자연스럽게 얻을 수 있다.

- 배포 독립성 : 특정 컴포넌트의 소스 코드가 변경되면 해당 코드가 포함된 컴포넌트만 다시 배포 
- 개발 독립성 : 시스템모듈을 독립적으로 배포할 수 있게되며, 각자 다른 팀에서 각 모듈을 독립적으로 개발

<br>

### 결론

>객체지향이란 다형성을 이용해 전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력이다. 
객체지향을 사용하면 아키텍트는 플러그인 아키텍처를 구성할 수 있고,
고수준의 정책을 포함하는 모듈은 저수준의 세부사항을 포함하는 모듈에 대해 독립성을 보장할 수 있다. 
또한 저수준의 세부사항은 중요도가 낮은 플러그인 모듈로 만들 수 있고, 고수준의 정책을 포함하는 모듈과는 독립적으로 개발하고 배포할 수 있다.

> 객체지향 프로그래밍은 제어흐름의 간접적인 전환에 부과되는 규율이다.

<br>

###### 출처 <br/>

###### [http://www.infobrother.com/Tutorial/C++/C++_Polymorphism][link01] <br/>
[link01]: http://www.infobrother.com/Tutorial/C++/C++_Polymorphism

###### [https://cheese10yun.github.io/spring-solid-dip/][link02] <br/>
[link02]: https://cheese10yun.github.io/spring-solid-dip/

